/*This is the implementation file for the project.
  Basically, we are overriding the methods which are generated by Antlr4 by using "ExprGrammarFile.g4".
  Method names come from the '#' sign as defined in "ExprGrammarFile.g4".
 */

import java.util.*;

public class EvalVisitor extends ExprGrammarFileBaseVisitor<Integer> {

    //Map and list are used to store variable names and their values
    Map<String, Integer> memory = new HashMap<String, Integer>();
    List printList = new ArrayList();

    //Boolean IsVisitPrint is used to call "CallPrint" function
    boolean IsVisitPrint = false;

    //Function for ID ':=' expr
    @Override
    public Integer visitAssign(ExprGrammarFileParser.AssignContext ctx) {
        String id = ctx.ID().getText();
        int value = visit(ctx.expr());

        //id and value are stored in hashmap "memory" for future use
        memory.put(id, value);
        printList.add("     POP AX");
        printList.add("     MOV " + id + ", AX");
        return 0;
    }

    //Function for 'print' expr
    @Override
    public Integer visitPrint(ExprGrammarFileParser.PrintContext ctx) {
        Integer value = visit(ctx.expr());
        String id = ctx.getText();
        printList.add("     POP AX");
        printList.add("     CALL print");
        //IsVisitPrint is assigned true to call CallPrint
        IsVisitPrint = true;
        return 0;
    }

    //Function for 'if' expr 'then' stm
    @Override
    public Integer visitIfthen(ExprGrammarFileParser.IfthenContext ctx) {
        //Implementation for condition
        visit(ctx.expr());
        //Random label declaration
        String randomLabel = RandomLabel(5);
        //If statement translation
        printList.add("     POP AX");
        printList.add("     CMP AX, 0");
        printList.add("     JZ " + randomLabel);
        //Implementation for instructions after then
        visit(ctx.stm());
        printList.add(randomLabel + ":");
        return 0;
    }

    //Function for 'while' expr 'do' stm
    @Override
    public Integer visitWhiledo(ExprGrammarFileParser.WhiledoContext ctx) {
        //Random label declaration
        String randomLabel1 = RandomLabel(5);
        String randomLabel2 = RandomLabel(5);
        //While statement translation
        printList.add(randomLabel1 + ":");
        //Implementation for condition
        visit(ctx.expr());
        printList.add("     POP AX");
        printList.add("     CMP AX, 0");
        printList.add("     JZ " + randomLabel2);
        //Implementation for insructions after do
        visit(ctx.stm());
        printList.add("     JMP " + randomLabel1);
        printList.add(randomLabel2 + ":");
        return 0;
    }

    //Function for 'begin' opt_stmts 'end'
    @Override
    public Integer visitBeginend(ExprGrammarFileParser.BeginendContext ctx) {

        //Assembly translation for Begin End
        visit(ctx.opt_stmts());
        return 0;
    }

    //Function for INT
    @Override
    public Integer visitInt(ExprGrammarFileParser.IntContext ctx) {
        //Integer pushed to stack
        printList.add("     PUSH " + ctx.NUM().getText());
        return 0;
    }

    //Function for ID
    @Override
    public Integer visitId(ExprGrammarFileParser.IdContext ctx) {
        String id = ctx.ID().getText();
        //id pushed to stack
        printList.add("     PUSH " + id);
        return 0;
    }

    //Function for iMul: expr op = iMUL expr
    @Override
    public Integer visitMul(ExprGrammarFileParser.MulContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));

        String randomLabel = RandomLabel(5);
        printList.add("     POP CX");
        printList.add("     POP AX");
        printList.add("     TEST AX, AX");
        printList.add("     JNS " + randomLabel);
        printList.add("     NEG AX");
        printList.add("     NEG CX");
        printList.add(randomLabel + ":");
        printList.add("     IMUL CX");
        printList.add("     PUSH AX");
        printList.add("     MOV DX, 0");
        return 0;
    }

    //Function for iDiv: expr op = iDIV expr
    @Override
    public Integer visitDiv(ExprGrammarFileParser.DivContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));

        String randomLabel = RandomLabel(5);
        printList.add("     POP CX");
        printList.add("     POP AX");
        printList.add("     TEST AX, AX");
        printList.add("     JNS " + randomLabel);
        printList.add("     NEG AX");
        printList.add("     NEG CX");
        printList.add(randomLabel + ":");
        printList.add("     IDIV CX");
        printList.add("     PUSH AX");
        printList.add("     MOV DX, 0");
        return 0;
    }

    //Function for Mod: expr op = MOD expr
    @Override
    public Integer visitMod(ExprGrammarFileParser.ModContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));

        printList.add("     POP CX");
        printList.add("     POP AX");
        printList.add("     DIV CX");
        printList.add("     PUSH DX");
        printList.add("     MOV DX, 0");
        return 0;
    }

    //Function for Add: expr op = ADD expr
    @Override
    public Integer visitAdd(ExprGrammarFileParser.AddContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));

        //Pop integer from the stack.
        printList.add("     POP CX");
        printList.add("     POP AX");
        printList.add("     ADD AX, CX");
        printList.add("     PUSH AX");
        printList.add("     MOV DX, 0");
        return 0;
    }

    //Function for Sub: expr op = SUB expr
    @Override
    public Integer visitSub(ExprGrammarFileParser.SubContext ctx) {
        int left = visit(ctx.expr(0));
        int right = visit(ctx.expr(1));

        //Pop integer from the stack
        printList.add("     POP CX");
        printList.add("     POP AX");
        printList.add("     SUB AX, CX");
        printList.add("     PUSH AX");
        printList.add("     MOV DX, 0");
        return 0;
    }

    //Function for parens: '(' expr ')'
    @Override
    public Integer visitParens(ExprGrammarFileParser.ParensContext ctx) {
        //Implementation for parenthesis
        return visit(ctx.expr());
    }

    //Random label generator for iMul, iDiv, While and If
    private static final String ALPHA_NUMERIC_STRING = "abcdefghijklmnopqrstuvwxyz";

    public static String RandomLabel(int count) {
        StringBuilder builder = new StringBuilder();
        while (count-- != 0) {
            int character = (int) (Math.random() * ALPHA_NUMERIC_STRING.length());
            builder.append(ALPHA_NUMERIC_STRING.charAt(character));
        }
        return builder.toString();
    }

    //Function for print
    public void CallPrint() {
        printList.add("print: ");
        printList.add("     TEST AX, AX");
        printList.add("     JNS positive");
        printList.add("     PUSH AX");
        printList.add("     MOV DX, '-'");
        printList.add("     MOV AH, 02H");
        printList.add("     INT 21H");
        printList.add("     POP AX");
        printList.add("     NEG AX");
        printList.add("positive:");
        printList.add("     MOV SI, 10d");
        printList.add("     XOR DX, DX");
        printList.add("     MOV CX, 0");
        printList.add("nonzero:");
        printList.add("     DIV SI");
        printList.add("     ADD DX, 48d");
        printList.add("     PUSH DX");
        printList.add("     INC CX");
        printList.add("     XOR DX, DX");
        printList.add("     CMP AX, 0h");
        printList.add("     JNE nonzero");
        printList.add("printloop:");
        printList.add("     POP DX");
        printList.add("     MOV AH, 02h");
        printList.add("     INT 21h");
        printList.add("     DEC CX");
        printList.add("     JNZ printloop");
        printList.add("     MOV DX, ' '");
        printList.add("     MOV AH, 02h");
        printList.add("     MOV DX, 0");
        printList.add("     INT 21h");
        printList.add("     ret");
        IsVisitPrint = false;
    }

    //Function for exit statement
    public void PrintExit()
    {
        printList.add("EXIT:");
        printList.add("     INT 20");

    }

    //Function for printing variables
    public void PrintData()
    {
        //Variable declaration for assembly code
        printList.add("DATA: ");
        for (int dataIndex = 0; dataIndex < memory.size(); dataIndex++) {
            printList.add(memory.keySet().toArray()[dataIndex] + " DW 0");
        }
    }

}
